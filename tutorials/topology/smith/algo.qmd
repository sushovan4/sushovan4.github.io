---
title-block-banner: true
title: Reduction of Integer Matrices
code-fold: false
execute: 
  echo: false
---
```{ojs}
viewof m = Inputs.range([1, 6], {
  value: 5,
  step: 1,
  label: "Number of rows (n):"
})
viewof n = Inputs.range([1, 6], {
  value: 4,
  step: 1,
  label: "Number of cols (m):"
})
```
## The Reduction Algorithm
Before we discuss the algorithm in detail, feel free to take a quick detour to see the [*reduction in action*](reduction.qmd)!

Given an integer matrix $A$ of any size, its reduction to the Smith normal form follows three major steps:

### Step 0: Set the offset
The algorithm relies on an `offset` parameter. Starting with `offset`=$1$, the reduction process works on the original matrix, inductively, by incrementing the offset. The offset determines how much of the matrix has been already been processed; it ranges from $1$ to $\min\{n,m\}$. When the function `reduce(offset)` is called, it assumes that the **offset-block**, block with the diagonal element `(offset,offset)` at its top-left corner, has to be processed, and all other rows and columns are already in good shape. 

To get an idea of how `offset` plays its role, try choosing an `offset` from the slider. If the reduction algorithm is called it would assume that the green elements are already processed, and the (gray) offset-block is yet to be processed.  
```{ojs}
viewof offset = Inputs.range([1, Math.min(n, m)], {
  value: 1,
  step: 1,
  label: `offset`
})
```
```{ojs}
{
  const container = d3.create("div").attr("class", "mat-container");

  container
    .selectAll(".row")
    .data(A)
    .join("div")
    .attr("class", "row")
    .selectAll("div")
    .data((d) => d)
    .join("div")
    .attr("class", "element")
    .text((d) => d);

  container
    .selectAll(".row")
    .filter((d, k) => k < offset - 1)
    .selectAll(".element")
    .style("background", "#BDF3C2");
  container
    .selectAll(".row")
    .selectAll(".element")
    .filter((d, k) => k < offset - 1)
    .style("background", "#BDF3C2");
  yield container.node();
}
```
**A Word of Caution:** Note, however, that the green rows and columns may not be yet processed in the following demo matrix.

### Step 1: Find the Best Pivot
For a given `offset`, we find the best pivot: a (non-zero) element that divides all other elements of the offset-block. This step involves finding repeatedly *a* pivot, then improving it. 

**Step 1.1 Find a `Pivot` and `antiPivot`:**   
For a given offset-block, a `pivot` is a *non-zero* element with the smallest absolute value; shown with a green border below. 

If the pivot-block is has all zero entries, we return the step. If not, a pivot can be found in $O(mn)$-time.

```{ojs}
{
  const container = d3.create("div").attr("class", "mat-container");

  container
    .selectAll(".row")
    .data(A)
    .join("div")
    .attr("class", "row")
    .selectAll("div")
    .data((d) => d)
    .join("div")
    .attr("class", "element")
    .text((d) => d);

  container
    .selectAll(".row")
    .filter((d, k) => k < offset - 1)
    .selectAll(".element")
    .style("background", "#BDF3C2");
  container
    .selectAll(".row")
    .selectAll(".element")
    .filter((d, k) => k < offset - 1)
    .style("background", "#BDF3C2");

  container
    .selectAll(".row")
    .filter((d, k) => k === pivot[0])
    .selectAll(".element")
    .filter((d, k) => k === pivot[1])
    .style("border", "2px solid green");

  container
    .selectAll(".row")
    .filter((d, k) => k === antiPivot[0])
    .selectAll(".element")
    .filter((d, k) => k === antiPivot[1])
    .style("border", "2px solid red");
  yield container.node();
}
```
We say that pivot can still be improved if, in the offset-block, there is an `antiPivot`: an element that does not divisible by the current `pivot`. In the demo, an `antiPivot` of a `pivot` is shown with a red border.

If `antiPivot` does not exist, we skip Step 1.1. Otherwise, we improve the `pivot`.

**Step 1.2 Improve the Pivot**
```{ojs}
{
  if (antiPivot.length === 0)
    return md`For the offset-block, we see that the pivot is already the best. So, we skip this step.`;
  else
    return md`For the offset-block, we see that the antiPivot exists. So, we take this step.`;
}
```
Let $[i,j]$ and $[s,t]$ be the positions of `pivot` and `antiPivot`.

**Case I ($i=s$):** 
If the `pivot` and `antiPivot` are on the same row, replace the antiPivot column by $q \times$ the pivot column, where $a_{it}= qa_{ij}+r$ with $0<r<a_{ij}$. As a result, $a_{it}$ becomes $r$ after the operations, and $a_{ij}$ fails to to the `pivot` for the output offset-block.  

**Case II ($j=t$):** 
same operation as in **Case I**, but for rows.

**Case III ($i\neq s, j\neq t$):** 
We assume for this case that $a_{ij}$ divides all entries (of the current offset-block) in its row and column. If not, we are back to Case I.

Using this assumption we can replace the antiPivot row by ${tex`q\times`} the pivot row, where $q=\frac{a_{sj}}{a_{ij}}$. After the operation, $a_{sj}$ becomes zero. If we now add replace the $i$-th row by adding it to the $s$-th row, $a_{ij}$ does not change, however the $(i,t)$-th becomes $a_{it}+a_{st}$, which is not divisible by $a_{ij}$, and we are back to Case I.

Each of the above cases yields a smaller `pivot`. We go back to Step 1.2 until the best pivot is found.

### Step 2: Move Pivot
Once the pivot is improved, we move the pivot to the top-left corner of the offset block by at most two elementary operations involving exchanging rows / columns.

### Step 3: Diagonalize
Since the pivot divides all other elements in the offset block, one can find the right multiplier $q$ for each row below and each column to its right to make entries zero by a series of operations involving replacing rows and columns.

We then increment the offset, and move to step 1.

**Result:**
```{ojs}
tex`D=${nj.mat2Tex(NF.D)}`
```

```{ojs}
tex.block`
Q^{-1}=${nj.mat2Tex(NF.Qinv)}\text{, and }
P=${nj.mat2Tex(NF.P)}
`
```
One can check that ${tex`D=Q^{-1}AP`}.

## Change of Bases
As we know now, the algorithm works by pre or post multiplying the original matrix $A$ by an elementary matrix at each step of the reduction. Let $E_1,E_2,\ldots,E_k$ and $F_1,F_2,\ldots,F_l$ be the elementary matrices corresponding to the row and column operations performed in the increaing order of the subscript. Then the final diagonal matrix $D$ can be written as:
$$D=E_k\ldots E_2.E_1.A.F_1.F_2\ldots F_l=Q^{-1}AP,$$
where $P=F_1.F_2\ldots F_l$ and $Q^{-1}=E_k\ldots E_2.E_1$.

We note that $P$ and $Q=E_1^{-1}E_2^{-1}\ldots E_k^{-1}$ are the basechange matrices for $\mathbb Z^m$ (domain) and $\mathbb Z^n$ (co-domain), respectively.

```{ojs}
tex.block`
\mathcal{B}=${nj.vec2Tex(B)}\text{, and }
\mathcal{B'}=${nj.vec2Tex(B1)}
`
```
Let $\mathcal{C},\mathcal{C}'$ be the new bases. We compute:
```{ojs}
tex`\mathcal{C}=${nj.vec2Tex(nj.changeBasis(B, NF.P))}`
```

```{ojs}
tex`\mathcal{C}'=${nj.vec2Tex(nj.changeBasis(B1, NF.Q))}`
```

## Discussion
If you are too excited to explore more on the subject, the reader is advised to call on [artin]. The examples in this tutorial are produced using codes from the JS package: [@tdajs/normal-form](https://www.npmjs.com/package/@tdajs/normal-form). Visit the Github [repo](https://github.com/tdajs/normal-form) for more information. Happy coding!

```{ojs}
nj = require("https://bundle.run/@tdajs/normal-form@2.0.0")
A = {
  let rows = n; //d3.randomInt(1, 10)();
  let cols = m; //d3.randomInt(1, 10)();

  return d3.range(0, rows).map((row) => {
    return d3.range(0, cols).map((elm) => d3.randomInt(-5, 5)());
  });
}
pivot = nj.findPivot(A, offset - 1)
antiPivot = nj.findAntiPivot(pivot, A, offset - 1)
NF = new nj.NormalForm(A)
B = Array.from({ length: m }).map((e, i) => "e_" + i)
B1 = Array.from({ length: n }).map((e, i) => "e_" + i + "'")
```
